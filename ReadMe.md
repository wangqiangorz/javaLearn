##### JVM的内存模型

![jvm](http://image.yehengchao.cn/superbed/2019/05/09/5cd395e53a213b041711257f.png)

- 线程私有：程序计数器、Java虚拟机栈、本地方法栈；
- 线程共享：Java堆、方法区（运行时常量池）。

程序计数器：指示当前线程所执行的字节码的行号指示器。保证线程切换后能够恢复到正确的执行位置，每个线程都有一个独立的程序计数器，互不影响，为线程私有的内存。循环、分支、方法跳转、异常处理，线程恢复都是依赖程序计数器来完成。

Java虚拟机栈：线程私有的，生命周期同线程的生命周期。每个方法在运行时都会创建一个栈帧用于存放局部变量表、操作数栈、动态链接、方法出口等信息。如下图：

![](http://image.yehengchao.cn/superbed/2019/02/15/5c66c1895f3e509ed98384f4.jpg)

局部变量表：存放编译期可知数据类型、对象引用类型和returnAddress类型。以变量槽（Variable Slot）为最小单位，每单位32位。

本地方法栈：为虚拟机使用到的Native方法服务，和虚拟机栈类似但并未强制规定其使用的语言，方式等。

Java堆：虚拟机所管理的内存中最大的一块，用于存放对象实例。线程共享。Java垃圾收集管理的主要区域，Java堆还可细分为：新生代和老年代。

方法区：和Java堆一样，线程共享的内存区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。一般此处不怎么需要回收，所以有的虚拟机使用永久代来实现方法区，该方法并不是个好主意。

运行时常量池：方法区的一部分，用于存放编译期生成的各种字面量和符号引用，并且转化以后的直接引用也放在这。

jdk1.8中方法区取消，用元数据空间代替并且移出了jvm内存，存在本地内存中。

##### GC算法

基于引用搜索算法，GCRoots向下遍历，能到达的即为存活对象，会发生Stop The World

GCRoots: 1）栈中引用的对象；2）方法区中的静态成员；3）方法区中的常量引用对象；4）本地方法栈中JNI引用的对象。

- 标记-清除算法
- 复制算法
- 标记-整理算法

引用种类：

1. 强引用：在代码中普遍存在，类似“Object obj = new Object()”这样，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。
2. 软引用：相对强引用弱化一些，可以让对象豁免一些垃圾收集，只有当jvm认为内存不足时，才会去试图回收软引用指向的对象。jvm确保在抛出OutOfMemoryError之前，清理软引用指向的对象。
3. 弱引用：非必须对象，强度比比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
4. 虚引用：是最弱的一种引用关系，无法通过虚引用来获取一个对象实例，为对象设置虚引用只是为了当这个对象被收集器回收时收到一条系统通知。

Minor GC：  

新生代分为Eden区和两个Survivor区，发生在新生代的垃圾收集叫做Minor GC。触发条件就是当新生代的Eden区满的时候。

过程：新生代共有两个Survivor区，分别用from和to指代。其中to指向的Survivor区是空的。当发生Minor GC时，Eden区和from指向的Survivor区中的存活对象会被复制（标记-复制算法）到to指向的Survivor区中，然后交换from和to指针，以保证下一次Minor GC的时候，to指向的Survivor区还是空的。如果在Minor GC的过程中，Survivor不足以容纳Eden和另外一个Survivor中的存活对象，则多余的存活对象将被移到老年代，称为过早提升。

##### 类加载相关

- 类加载器：把“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到虚拟机外部实现。实现这个动作的模块称之为类加载器。

- 类加载过程：整个生命周期：加载、连接（验证、准备、解析）、初始化、使用、卸载。

  在加载阶段，虚拟机需要完成以下3件事情：

  1. 通过类的全限定名来获取定义此类的二进制字节流。
  2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
  3. 在内存中生成一个代表该类的Class对象，用来作为方法区这个类各个数据的访问入口。

  准备阶段正式为类变量分配内存并设置类变量（**注意：这里的类变量指的是被static修饰的变量**）的初始值，一般为0值，但是声明为final类型的变量则在准备阶段就将类变量赋值为程序里所给的值。

  解析阶段是虚拟机将常量池内的符号引用替换为直接引用。

  ps:相同的一个类文件Class，被不同的两个类加载器加载以后得到两个类，这两个类必定不相等。

- 双亲委派模型：对于Java虚拟机来说，类加载器只有两类，一类是系统提供的称为启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分；另一类是Java应用开发人员编写，独立于虚拟机外部，全都继承自抽象类java.lang.ClassLoader。

  从开发人员的角度分类，绝大多数Java程序会使用到以下3种系统提供的类加载器。

  - 启动类加载器（Bootstrap ClassLoader）：负责加载<JAVA_HOME>\lib目录下的或者被-Xbootclasspath参数指定的路径中的类库，将其加载到虚拟机内存中。无法被Java程序直接引用，并不继承自java.lang.ClassLoader。
  - 扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
  - 应用程序类加载器（Application ClassLoader）：也称为系统加载器，负责加载用户类路径（ClassPath）上所指定的类库。

  双亲委派模型的工作过程如下：当一个类加载器收到类加载的请求，它并不会自己去加载这个类而是将这个加载任务委派给父类加载器去完成，每一个层次的类加载器都是如此，所以永远是父加载器优先加载。

  双亲委派模型对于保证Java程序的稳定运作很重要。

##### Class对象

1. Class也是类的一种；
2. Class类的对象内容是你创建的类的类型信息，比如创建一个shape类，那么Java就会生成一个内容是shape的Class类的对象；
3. Class类的对象不能像普通类一样，以new XXX() 的形式创建，它的对象只能由JVM创建，因为这个类没有public构造函数；
4. Class类的作用是运行时提供或获得某个对象的类型信息。

##### 锁

悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。

乐观锁：假设总是最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会去判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样就可以提高吞吐量。

使用场景：

两种锁各有优缺点，乐观锁适用于多读少写的场景；悲观锁则相反。

CAS算法和版本号机制问题

##### Redis持久化

RDB快照：支持将当前数据的快照存成一个数据文件的持久化机制。在生成快照时，将当前进程fork出一个子进程（Save阻塞当前进程，BGSave不阻塞），然后在子进程中循环所有的数据，将数据写成为RDB文件。可以设置触发条件，多个也可以。缺点：一旦数据库出现问题，那么RDB文件中保存的数据并不是全新的，从上次RDB文件生成到Redis停机这段时间额数据全部丢掉了。对于一些对数据安全性要求极高的应用就不适用。

AOF日志：全称append only file，是一个追加写入的日志文件。AOF文件是可识别的纯文本，其内容就是一个个的Redis标准命令。每一条命令都生成一条日志，这样会导致AOF文件很大，所以Redis提供了一个AOF rewrite功能，用来重新生成一份AOF文件，新的AOF文件中一条记录的操作只会有一次，而不像一份老文件一样可能记录了对同一个值的多次操作。

持久化的时候父进程会fork一个子进程来执行，首先自己肯定不能来做，因为还要响应客户端的请求，其次也不能用新线程，因为新线程必定会导致数据的争夺，这样会造成对数据的竞争条件，为了避免使用锁降低性能。

<https://draveness.me/whys-the-design-redis-bgsave-fork/>

##### Redis高性能剖析

1. 完全基于内存，绝大部分请求是纯粹的内存操作，速度很快。
2. 数据结构简单，对数据操作也简单。Redis中的数据结构是专门进行设计的；
3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多线程切换导致消耗CPU，不用去考虑各种锁的问题。
4. 使用多路IO复用模型（多个网络连接复用同一个线程）。
5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

##### 输入网址到页面加载的过程

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

##### 跨域问题

同源策略/SOP：是一种约定，浏览器的最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。同源指“协议+域名+端口”三者相同，即使两个不同的域名指向同一个ip地址，也非同源。

跨域：在HTML中，<a>，<form>，<img>等标签以及Ajax都可以指向一个资源地址，跨域请求指：当前发起请求的域与该请求指向资源所在的域不一样。

##### CDN的用途

CDN解决的是如何将数据快速可靠从源站传递到用户的问题。用户获取数据时，不需要直接从源站获取，通过CDN对于数据的分发，用户可以从一个较优的服务器获取数据，从而达到快速访问，并减少源站负载压力的目的。

##### ArrayList

默认容量为10，初始化的时候如果无参数，或者容量设置为0都是空数组，在第一次add的时候扩容到10。也可以自定义容量，初始化时即生成相应的数组。

当容量不够时需要扩容，默认情况下新的容量是原容量的1.5倍，其实现使用了位运算以提高效率。在不使用自动扩容的情况下，如果用户知道所用数组容量固定，也可以使用ensureCapacity手动扩容，这样扩一次就好了。扩容底层调用了Arrays.copyOf方法。

“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。

##### equals()和hashcode()

java中HashMap使用hashcode()和equals()来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确实现这两个方法，两个不同的键可能会有相同的hash值，集合会认为是相等的。反过来说，重写了equal方法但是hashcode不一样，集合还是认为两个对象不一样。

##### java并发

缓存不一致问题的解决方法：

1. 通过在总线加LOCK#锁的方式
2. 通过缓存一致性协议

这两种方法都是硬件层面上提供的。

volatile

一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后就具备了两层语义：

1. 保证了不同线程对这个变量进行操作时的可见性；
2. 禁止进行指令重排序。

**volatile只能保证变量的可见性，无法保证对变量的操作都是原子性的**

```java
//x、y为非volatile变量
//flag为volatile变量
 
x = 2;        //语句1
y = 0;        //语句2
flag = true;  //语句3
x = 4;         //语句4
y = -1;       //语句5
```

由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。

原理：使用lock指令，相当于一个内存屏障。

synchronized

当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其它线程暂时无法访问这个方法只有等待这个方法执行完毕，线程释放该对象的锁，其它线程才能执行这个方法或代码块。

- 当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized方法。
- 当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。这个原因很简单，访问非synchronized方法不需要获得该对象的锁，假如一个方法没用synchronized关键字修饰，说明它不会使用到临界资源，那么其他线程是可以访问这个方法的。
- 如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的synchronized方法fun1，即使object1和object2是同一类型），也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。

原理：synchronized代码实际上多了monitorenter和monitorexit两条指令，让对象的锁计数加1或者减1，类似操作系统中的PV操作。如果发生异常，线程会自动释放锁。

PS：如果synchronized修饰的类中的静态方法或者.class，则获取到的是类锁而不是上面的对象锁。类锁只是一个概念，实际上是用对象锁来实现。当虚拟机装载一个class文件的时候，就会创建一个java.lang.Class类的实例。所以类锁实际上锁住的是那个类对应的Class对象。

##### Java中的反射

在运行状态中，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性（包括私有的方法和属性），这种动态获取的信息以及动态调用对象的方法的功能就称为Java的反射机制。

获取字节码文件对象的三种方式：

1. Class.forName("全限定类名")
2. XXX.class
3. XXX.getClass()

然后调用Class类的newInstance() 方法，就能创建实例对象。

##### sleep()和wait()

- sleep()使正在执行的线程主动让出CPU，sleep指定时间后再回到该线程继续往下执行，**sleep只会让出CPU，而不会释放同步资源锁**；
- wait指当前线程让自己暂时退让出同步资源锁，以便其它正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法线程才会解除之前的wait状态，**notify()并不会分配任务，只是让之前调用了wait的线程有权利重新参与线程的调度**。

##### 动态代理

我们很少去使用动态代理机制，一般在很多框架中较多使用如Spring。

AOP作为Spring的核心，其原理就是java的动态代理机制，在java的动态代理中有两个重要的类或接口，一个是InvocationHandler(Interface)、另一个则是Proxy(Class)，这是实现动态代理所必须用到的。

每一个动态代理类都必须实现 InvocationHandler 这个接口，并且每个代理类的实例都关联到了一个handler，通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。

```java
Object invoke(Object proxy, Method method, Object[] args) throws Throwable

// proxy:　　指代所代理的那个真实对象
// method:　　指代的是所要调用真实对象的某个方法的Method对象
// args:　　指代的是调用真实对象某个方法时接受的参数
```

Proxy类的作用就是用来动态创建一个代理对象的类，它提供了很多方法，但是用到最多的就是newProxyInstance这个方法：

```java
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,  InvocationHandler h)  throws IllegalArgumentException

// loader:　　一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载
// interfaces:　　一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样就能调用这组接口中的方法了
// h:　　一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上
Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler);
//	这里的接口是Subject类型，所以就可以将其转化为Subject类型了。
```

通过 Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，它并不是InvocationHandler类型，也不是定义的那组接口的类型，而是在运行时动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。

##### 抽象类和接口

| **参数**           | **抽象类**                                                   | **接口**                                                     |
| :----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 默认的方法实现     | 它可以有默认的方法实现                                       | 接口完全是抽象的。它根本不存在方法的实现                     |
| 实现               | 子类使用**extends**关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字**implements**来实现接口。它需要提供接口中所有声明的方法的实现 |
| 构造器             | 抽象类可以有构造器                                           | 接口不能有构造器                                             |
| 与正常Java类的区别 | 除了你不能实例化抽象类之外，它和普通Java类没有任何区别       | 接口是完全不同的类型                                         |
| 访问修饰符         | 抽象方法可以有**public**、**protected**和**default**这些修饰符 | 接口方法默认修饰符是**public**。你不可以使用其它修饰符。     |
| main方法           | 抽象方法可以有main方法并且我们可以运行它                     | 接口没有main方法，因此我们不能运行它。                       |
| 多继承             | 抽象方法可以继承一个类和实现多个接口                         | 接口只可以继承一个或多个其它接口                             |
| 速度               | 它比接口速度要快                                             | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。   |
| 添加新方法         | 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 | 如果你往接口中添加方法，那么你必须改变实现该接口的类。       |

##### Overload 和 Override 

**Override**  可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：

1. 覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；
2. 覆盖的方法的返回值必须和被覆盖的方法的返回值一致；
3. 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；
4. 被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。

**Overload**  可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点：

1. 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int,float)，但是不能为 fun(int,int)；  
2. 不能通过访问权限、返回类型、抛出的异常进行重载；
3. 方法的异常类型和数目不会对重载造成影响；
4. 对于继承来说，如果某一方法在父类中是访问权限是 private，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。

##### 理解多态

定义
多态，是面向对象的程序设计语言最核心的特征。多态，意味着一个对象有着多重特征，可以在特定的情况下，表现不同的状态，从而对应着不同的属性和方法。

实现技术
动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。

作用
消除类型之间的耦合关系。

体现：Override（重写）

##### HashMap和Concurrenthashmap

HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。数组中的元素是Entry类型的，每个Entry就是一个key-value的键值对，还包含一个next的Entry指针。

当使用put方法时，首先对key进行hash得到哈希值，根据哈希值求出数组中的索引。若数组该位置为空则直接放入Entry，否则一直往下遍历比较当前Entry的key和待放入的key是否相等（使用equals方法），相等则覆盖，否则新加入的Entry放在链尾（1.8之前插在链头）。HashMap中计算对象所对应的table位置方法很巧妙，通过h&(table.length-1)来得到相应的index，因为HashMap底层数组长度总是2的n次方，所以算出来的结果就等价于对length取模，但却比直接取余更高效。

1.8中HashMap除了链表节点还引入了红黑树，链表长度大于8的时候转化为红黑树。

ConcurrentHashMap相当于是线程安全的HashMap，多了Segment的概念，每个Segment对象守护整个散列映射表的若干个桶，理解为在HashMap的基础上再封装一个数组，分成几段来加锁（jdk1.7的做法）。

HashMap线程不安全的原因

1. put方法导致多线程数据不一致。如现在有两个线程A和B，首先A执行put方法，即将插入一个key-value对到HashMap中，计算完成以后得到所要落到的桶的索引坐标，然后获取到该桶里面的链表头节点，此时A时间片耗尽切换到B线程，B也要执行put方法并且刚好需要put的记录计算得到的桶索引是一样的，那么当B成功插入之后，A再次被调度运行时，B操作的结果对其不可见，如此一来就覆盖了B插入的记录。
2. get操作可能因为resize而引起死循环（因为put插入是头插，导致resize前后链表元素的顺序是相反的，所以会出现环的情况，1.8以后尾插所以并没有这个问题了）。

##### 常用排序的优缺点

- 冒泡排序

  通过与相邻元素的比较和交换来把最小的数交换到最前面。时间复杂度为O(n^2).

- 选择排序

  冒泡排序的改良版，每次遍历一遍，把剩余最小的数与最前面的数交换，这样每一次遍历完就只需要进行一次交换。时间复杂度为O(n^2).

- 插入排序

  和选择排序类似，但不是通过交换而是插入来找到合适的位置，首先将第一个数作为基数往后选择，将选择的数从前往后遍历找到合适的位置插入（比前一个数大，比后一个数小）。时间复杂度为O(n^2).

- 快速排序

  基于冒泡排序的思想，比较和交换小数和大数，能把小数冒泡到上面，也把大数沉到了下面。定义两个指针，右指针找比基数小的数（一定要右指针先动，这样最后停止的地方才确保比基数小，才能和基数交换位置），左指针找比基数大的数交换。一轮下来就会使一个数的位置确定，这个数左边的数都比他小，右边都比他大。两边继续快速排序。平均复杂度O(nlgn).

- 堆排序

  利用堆这种数据结构而设计的排序算法，堆是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值，成为大顶堆；或者每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。首先建立初始堆，然后从左至右，从下至上进行调整，交换重建，使其最终形成一个有序的堆。平均复杂度为O(nlgn).

- 归并排序

  利用归并的思想实现，将问题分成一些小问题然后递归求解，后面将分的小问题得到的答案再“修补”在一起。平均复杂度为O(nlgn).

##### http和https

- http协议用于在浏览器和服务器之间传递信息，以明文方式发送内容。
- https在http基础上加入了SSL协议，SSL依靠证书来验证服务器的身份并为浏览器和服务器之间的通信加密。

https作用：1）建立一个信息安全通道保证数据传输的安全；2）确认网站的真实性。

https的工作原理：

- 客户端发起https请求

  输入一个https网址，然后连接到server的443端口

- 服务器的配置

  使用https协议的服务器必须要有一套数字证书，证书其实是一对公钥和私钥

- 传送证书

  该证书即为公钥，而且包含了很多信息，比如证书的颁发机构、过期时间等等。

- 客户端解析证书

  客户端TLS首先验证公钥是否有效（颁发机构、过期时间等），若证书没问题则生成一个随机值并且用证书对该随机值进行加密。

- 传送加密信息

  客户端将加密后的随机值发送给服务器，之后客户端和服务端之间的通信就可以通过这个随机值进行加密解密。

- 服务端解密

  服务端收到客户端发送的密文并用私钥进行解密得到随机值，然后把该随机值和内容进行非对称加密（即将信息和私钥通过某种算法混合在一起，除非知道私钥，不然无法获取内容），返回给客户端。

- 客户端解密信息

  客户端用之前生成的私钥解密服务端的信息，获得解密后的内容。

##### TCP三次握手

第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

##### TCP和UDP

1. 基于连接与无连接；
2. 对系统资源的要求（TCP较多，UDP少）；
3. UDP程序结构较简单；
4. 流模式与数据报模式；
5. TCP保证数据正确性，UDP可能丢包；
6. TCP保证数据顺序，UDP不保证。

##### TCP的拆、粘包

TCP是一个面向字节流的协议，它的性质是流式的，所以并不会分段。根据当前的套接字缓冲区的情况进行拆包或者粘包。当客户端发送两个数据包的情况下，服务器端接收可能会有很多种情况，滑动窗口小的情况一个报文就会被拆成好多小包，或者两个报文合成一个包。这样接收端应用程序就很难处理了。对于这样的问题，常见的解决方式有：

- 在报文末尾增加换行符表明一条完整的消息，这样接收端就可以根据这个换行符来判断消息是否完整。
- 将报文再次封装，增加一个消息头，在消息头中声明消息的长度，根据这个长度来获取报文。
- 规定好报文长度，不足的长度用空位补齐，取的时候按照长度截取即可。

##### TCP和UDP

|            | TCP            | UDP        |
| ---------- | -------------- | ---------- |
| 是否连接   | 面向连接       | 面向非连接 |
| 传输可靠性 | 可靠的         | 不可靠的   |
| 应用场合   | 传输大量的数据 | 少量数据   |
| 速度       | 慢             | 快         |

##### TCP的拥塞控制机制

![](http://image.yehengchao.cn/superbed/2019/05/27/5ceb5532451253d178f0a105.png)

- 慢启动

  慢启动在TCP数据传输的开始阶段，当主机开始发送数据时并不知道当前网络状况如何，所以不能立即大量发送大量的数据。所以TCP采用试探的方法逐渐增大拥塞窗口。刚开始发送方知能发送1个报文段；当收到确认后，将拥塞窗口加倍，所以之后发送方能够发送的报文段数量为：2、4、8…….  慢启动并不是说启动过程增长慢，而是说初始的发送窗口小。

- 拥塞避免

  慢启动每次增长都是加倍的，所以为了防止拥塞窗口增长过快而引起网络拥塞，TCP会设置一个慢启动阈值，当拥塞窗口的值增加到该阈值时，就要减缓拥塞窗口的增长速度，具体的做法是每经过一个RTT（数据报文发出到收到确认的时间），拥塞窗口的值加1，这样就能使窗口的大小缓慢增长。当拥塞避免算法执行到某个时刻时，还是会发生网络拥塞导致发送方在规定时间内没有收到接收端的确认。此时发送端将慢启动阈值设置为发生超时窗口大小的一半，同时将拥塞窗口置为1重新执行慢启动算法。

- 快速重传

  接收端每收到一个失序的数据报文段后就立即发出重复确认。假设某个TCP数据传输过程中接收端依次收到发送端发出的1号和2号数据报文段，并对这两个数据报文发送确认后，没有按次序收到3号数据报文段，而是收到了4号，这时就需要立即向发送端发送2号数据报文段的确认，称为重复确认。同理，如果继续收到5号、6号报文段，接收端仍要向发送端发送2号数据报文的重复确认。此时发送端会收到多个2号数据报文的重复确认，则认为3号数据报文段发生了丢包，需要立即向接收端重传3号报文。

- 快速恢复

  配合快速重传使用，当发送端连续收到三个重复确认时，就将慢启动阈值减半，预防网络拥塞的发生，并且将拥塞窗口的值置为减半后的慢启动阈值，然后开始执行拥塞避免算法，使拥塞窗口缓慢增加。

##### 单点登录

Http是无状态的，服务器通过客户端访问请求时发送的Cookie来确认用户的信息而Session就是服务器上的“用户明细表”，通过Cookie中的ID来查找Session，确认用户的身份。配合数据库使用：用户登录时验证账号密码，通过后生成一个Token保存数据库，同时将Token写到Cookie并且将用户数据保存在Session中，用户请求时带上Cookie，检查有没有登录。

Session共享

多系统的情况下存在多个服务器，Session只依赖当前系统的服务器，所以不同系统的Session是不共享的。所以解决系统之间Session不共享问题有以下几种方案：

1. Tomcat集群Session全局复制（集群内每个tomcat的Session完全同步），影响集群性能。
2. 根据请求的IP进行Hash映射到对应的机器上，这样一来同一个IP的客户端会一直访问同一个服务器，但是如果服务器宕机了，会丢失一大部分Session数据。
3. 把Session数据放入Redis中，使用Redis模拟Session。

首先将登录功能作为一个单系统，其它系统登录时，请求登录系统进行登录，将返回的token写到Cookie中，下次访问时则把Cookie带上。

Cookie跨域

由于域名不同，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。针对这个问题，有以下几种解决方案：

1. 服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析，此后请求都把这个Token带上就行了。
2. 多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。
3. 将Token保存在SessionStorage中。

##### SpringMVC处理请求

  ![](http://image.yehengchao.cn/superbed/2019/05/27/5ceb5532451253d178f0a109.png)

##### 线程和进程

进程和线程是不同操作系统资源管理方式，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。所以多进程的程序比多线程的程序健壮。

##### Java线程状态

1. NEW：线程新建状态，尚未启动的线程状态。
2. BLOCKED：阻塞状态，受阻塞并且正在等待锁的某一线程的线程状态。
3. RUNNABLE：可运行线程的线程状态。（包括两种情况：1.RUNNABLE，线程调用了start()方法但是在时间片内未执行完run方法体，或从BLOCKED状态结束；2.RUNNING，此时线程获得CPU）。
4. WAITING：等待状态，进入此状态后线程无限等待，直到其他线程做出一些特定的动作（唤醒、中断）才会再次运行。
5. TIMED_WAITING：计时等待状态，与WAITING类似但是有时间限制，只会等待一段指定的时间。
6. TERMINATED：终止状态，已终止线程的线程状态。

##### 线程池

优点：

1. 避免线程的创建和销毁带来的性能开销。
2. 避免大量的线程间因互相抢占系统资源导致的阻塞现象。
3. 能够对线程进行简单的管理并提供定时执行、间隔执行等功能。

参数

- corePoolSize：核心线程数

  核心线程一直存活，即使没有任务需要执行。

  当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理。

- maxPoolSize：最大线程数

  当线程数大于核心线程数且任务队列已满时，线程池会创建新线程来处理任务。

  当线程数等于最大线程数且任务队列已满时，线程池会拒绝处理任务而抛出异常。

- keepAlivaTime：线程空闲时间

  当线程空闲时间达到keepAlivaTime时，线程会退出，直到线程数量等于核心线程数。

拒绝策略：

1. 丢弃任务并抛出RejectedExecutionException异常
2. 丢弃任务但是不抛出异常
3. 丢弃队列最前面的任务，然后重新尝试执行任务
4. 由调用线程处理该任务

##### Java支持的8种基本数据类型

byte（字节型）、short（短整型）、int（整型）、long（长整型）、float（单精度浮点型）、double（双精度浮点型）、boolean（布尔型）、char（字符型）

##### http状态码

| 分类 | 分类描述                                       |
| ---- | ---------------------------------------------- |
| 1xx  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2xx  | 成功，操作被成功接收并处理                     |
| 3xx  | 重定向，需要进一步的操作以完成请求             |
| 4xx  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5xx  | 服务器错误，服务器在处理请求的过程中发生了错误 |

##### 数据库中的事务

事务的四个属性：

1. 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
2. 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致性状态的含义是数据库中的数据应满足完整性约束。
3. 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应该影响其它事务的执行。
4. 持久性（Durability）：一个事务一旦提交，它对数据库的修改应该永久保存在数据库中。

不考虑事务隔离性情况：

1. 脏读

   指在一个事务处理过程里读取了另一个未提交的事务中的数据。

2. 不可重复读

   指对于数据库中的某个数据，一个事务范围内多次查询却返回了不同数据值；由于在查询间隔，数据被另一个事务修改并提交了。与脏读的区别：脏读是读取另一事务未提交的脏数据，不可重复读是读取前一事务提交的数据。

3. 虚读（幻读）

   指事务非独立执行时发生的现象，如事务T1对表中所有行的某个字段做了修改；这时事务T2又对这个表中插入一行数据项，该数据项的这个字段还是未修改前的。此时事务T1再查看刚刚修改的数据，会发现还有一行没有修改，就好像产生幻觉一样。

数据库隔离级别：

1. 串行化：可避免脏读、不可重复读、幻读的发生。
2. 可重复读：可避免脏读、不可重复读的发生。
3. 读已提交：可避免脏读的发生。
4. 读未提交：最低级别，任何情况都无法保证。

##### 数据库表的拆分

- 垂直拆分

  指数据表列的拆分，把一张列比较多的表拆分成多张表，通常按照以下原则进行垂直拆分：

  1. 把不常用的字段单独放在一张表；
  2. 把text, blob等大字段拆分出来放在附表；
  3. 经常组合查询的列放在一张表中。

- 水平拆分

  指数据表行的拆分，表的行数量级很大时速度就会变慢，这时可以把一张表的数据拆分成多张表来存放。

  可以是哈希；

  也可以根据业务需求。

##### 数据库索引类型

1. 唯一索引

   UNIQUE  表明此索引的每一个索引值只对应唯一的数据记录，对于单列唯一性索引，这保证单列不包含重复的值。对于多列唯一性索引，保证多个值的组合不重复。

2. 主键索引

   primary key  数据库表中经常有一列或列组合，其值唯一标识表中的一行。该列称为表的主键。为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当查询中使用主键索引时，还允许对数据的快速访问。

3. 普通索引

   最基本的索引，没有任何限制。
   
4. 全文索引

   大量文本数据检索使用，效率比like高

5. 组合索引

   比如一个a, b, c的组合索引相当于a, ab, abc三个索引，匹配依据“最左前缀”规则，就是只从最左边的开始组合。

##### 建索引的几大原则

1. 选择唯一性索引
2. 为经常需要排序、分组等操作的字段简历索引
3. 为常作为查询条件的字段建立索引
4. 限制索引的数目
5. 尽量使用数据量少的索引

##### 文件系统和数据库为何选择B+树索引

1. 磁盘IO比内存操作性是相差千级数量级的差异，因此应该尽量减少io操作。
2. 磁盘组织形式是扇区，因为数据的局部性，因此一次磁盘io会把一个扇区都预读出来，也就是说一次读1字节的数据和4k字节（一个扇区）需要的时间是几乎一样的。

索引的目标是要找到数据所在的物理位置，因此用树去实现搜索数据所在的物理位置，每个节点相应发生一次io，所以为了减少搜索时间就需要控制树的高度，因此采用B+树的形式。采用B+树时在相同数据量的情况下如何降低树的高度？当然是增加每一层的数据量，而考虑到2，一个节点对应一个扇区大小存储多个数据项，既可以降低索引文件大小，又可以在相同数据量的情况下减少每层节点数，提高性能。

##### 索引失效的情况

1. 条件中有or，即使其中有条件带索引也不会使用
2. 字符串不加单引号索引失效
3. 用like时，通配符%开头索引失效

##### 对比平衡二叉树、红黑树、B树、以及B+树

- 平衡二叉树

  左子树和右子树的深度差的绝对值小于等于1

  属于二叉搜索树（左子树的值都小于当前节点，右子树的值都大于当前节点）

- 红黑树

  是一种平衡二叉树，红黑树的每个节点都有存储位表示节点的颜色，黑色和红色两种。

  特性：

  1. 每个节点或者是黑色，或者是红色。
  2. 根节点是黑色，每个叶子节点都是黑色（这里的叶子节点是指空的叶子节点NULL）
  3. 如果一个节点是红色，则它的子节点必须是黑色的。
  4. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点

- B树

  是一种多路搜索树（非二叉），一颗m阶B树是一颗平衡的m路搜索树。

  特性：

  1. 根节点至少有两个子女
  2. 每个非根节点所包含的关键字个数j满足┌m/2┐ – 1 <= j <= m – 1
  3. 除根节点以外的所有节点（不包含叶子节点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ <= k <= m 
  4. 所有的叶子节点都位于同一层

  总结：搜索有可能在非叶子节点结束、其搜索性能等价于在关键字全集内做一次二分查找

- B+树

  是B树的变体，也是一种多路搜索树

  特性：

  1. 所有关键字都出现在叶子节点的链表中，且链表中的关键字恰好是有序的
  2. 不可能在非叶子节点命中
  3. 非叶子节点相当于叶子节点的索引，叶子节点相当于是存储数据的数据层
  4. 适合文件索引系统
  5. 所有叶子节点都有一个链指针

##### 跳表

skiplist本质上也是一种查找结构，用于解决算法中的查找问题，即根据给定的key快速查到它所在的位置。

首先，多层链表的结构如下：

![](http://image.yehengchao.cn/superbed/2019/07/12/5d287043451253d1782b6c4a.png)

在新的多层链表上，先从第一层开始查找，逐步向下。可以想象当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。相当于二分查找。

但是上述这种方法在插入数据的时候有很大的问题，新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。所以跳表不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数。如下面这个过程：

![](http://image.yehengchao.cn/superbed/2019/07/14/5d2af259451253d1783f9bf2.png)

##### 单例实现

1. 懒汉式，线程不安全

   ```java
   public class Singleton {
       private static Singleton instance;
       private Singleton (){}
       public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
       }
   }
   ```

   多线程下不能正常工作，会创建多个实例

2. 懒汉式，线程安全

   ```java
   public static synchronized Singleton getInstance() {
       if (instance == null) {
           instance = new Singleton();
       }
       return instance;
   }
   ```

   直接将方法加锁，虽然线程安全，但是不高效

3. 双重检验锁，有问题

   ```java
   public static Singleton getSingleton() {
       if (instance == null) {                         //Single Checked
           synchronized (Singleton.class) {
               if (instance == null) {                 //Double Checked
                   instance = new Singleton();
               }
           }
       }
       return instance ;
   }
   ```

   new Singleton()并不是原子操作，分为三个步骤：

   - 给instance分配内存
   - 调用Singleton的构造函数来初始化成员函数
   - 将instance对象指向分配的内存空间（执行完这一步instance就不是null了）

   但是JVM存在指令重排序的优化。所以上面的第二步和第三步的顺序是不能保证的，如果上面的执行顺序是1-3-2，则在3执行完毕，2未执行之前线程被抢占了，此时instance已经是非null了（但是还未被初始化），所以抢占的线程直接返回instance，使用的话就会报错。

   解决方法：将instance变量声明成volatile

   ```java
   public class Singleton {
       private volatile static Singleton instance; //声明成 volatile
       private Singleton (){}
   
       public static Singleton getSingleton() {
           if (instance == null) {                         
               synchronized (Singleton.class) {
                   if (instance == null) {       
                       instance = new Singleton();
                   }
               }
           }
           return instance;
       }
      
   }
   ```

   主要原因是volatile声明的变量的赋值操作后面会插入一个内存屏障，读操作不会被重排序到内存屏障之前。

4. 饿汉式

   声明成static和final变量，这样一来在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的

   ```java
   public class Singleton{
       //类加载时就初始化
       private static final Singleton instance = new Singleton();
       
       private Singleton(){}
   
       public static Singleton getInstance(){
           return instance;
       }
   }
   ```

   这不是一种懒加载模式，单例会在加载类后一开始就被初始化，即使客户端没有调用getInstance()方法。饿汉式的创建方式一些场景中将无法使用，比如Singleton实例的创建是依赖参数或者配置文件的。

5. 静态内部类

```java
public class Singleton {  
    private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton();
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE; 
    }
}


```

这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。

##### 编译型和解释型语言

1，编译型语言在编译过程中生成目标平台的指令，解释型语言在运行过程中才生成目标平台的指令。
2，虚拟机的任务是在运行过程中将中间代码翻译成目标平台的指令。

##### Nginx相关

- Nginx架构

  nginx启动以后，在unix系统中以daemon方式在后台运行，后台进程包含一个master进程和worker进程。nginx是以多进程的方式来工作的，也可以使用多线程方式，但是主流还是多进程的方式，也是nginx的默认方式。

- 操作nginx

  nginx中是master来管理worker进程的，所以只需要与master进程通信就行了，master进程接收来自外界发来的信号，再根据信号做不同的事情。比如 ./nginx -s reload 命令，执行命令时启动一个新的nginx进程，新的nginx进程解析reload参数，向master发送信号，然后master接到信号后启动新的worker进程，并且向老的worker进程发送信号，告诉他们不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后再推出。新的worker在启动后就开始接收新的请求。

- nginx请求处理方式：异步非阻塞。具体到系统调用就是像select/poll/epoll这样的系统调用。可以同时监控多个事件。

